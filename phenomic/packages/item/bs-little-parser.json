{"filename":"bs-little-parser.json","type":"published","id":"bs-little-parser","name":"bs-little-parser","version":"0.3.4","description":"Little parser combinator for BuckleScript or Reason.","author":"henoc","license":"MIT","keywords":["bucklescript","reason"],"analyzed":"2017-12-20T17:55:30.744Z","updated":"2017-12-20T17:55:30.744Z","stars":2,"score":0.5805662802940511,"quality":0.7011076458988124,"popularity":0.06343577343005206,"maintenance":0.9943756166396833,"homepageUrl":"https://github.com/Henoc/bs-little-parser#readme","repositoryUrl":"https://github.com/Henoc/bs-little-parser","npmUrl":"https://www.npmjs.com/package/bs-little-parser","issuesUrl":"https://github.com/Henoc/bs-little-parser/issues","docsUrl":null,"path":"packages/bs-little-parser","body":"<h1 id=\"bs-little-parser\"><a aria-hidden=\"true\" href=\"#bs-little-parser\"><span class=\"icon icon-link\"></span></a>bs-little-parser</h1>\n<p>Little parser combinator for BuckleScript or Reason.</p>\n<h2 id=\"usage\"><a aria-hidden=\"true\" href=\"#usage\"><span class=\"icon icon-link\"></span></a>Usage</h2>\n<pre><code class=\"hljs language-ml\"><span class=\"hljs-keyword\">open</span> <span class=\"hljs-type\">BsLittleParser</span>.<span class=\"hljs-type\">Parser</span>\n\n<span class=\"hljs-keyword\">let</span> input = <span class=\"hljs-type\">BsLittleParser</span>.<span class=\"hljs-type\">Input</span>.{text = <span class=\"hljs-string\">\"abcabc  abc\"</span>; index = <span class=\"hljs-number\">0</span>; whitespace = <span class=\"hljs-string\">\" \"</span>}\n\n<span class=\"hljs-keyword\">let</span> abc = stringParser <span class=\"hljs-string\">\"abc\"</span>\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">()</span> =\n  input\n  |> rep abc\n  |> <span class=\"hljs-type\">Js</span>.log</code></pre>\n<p>Type <code>Input.t</code> has a whitespace which specify a character sequence should be ignored.</p>\n<h2 id=\"parsers\"><a aria-hidden=\"true\" href=\"#parsers\"><span class=\"icon icon-link\"></span></a>Parsers</h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th align=\"left\">parser</th><th align=\"left\">description</th></tr></thead><tbody><tr><td align=\"left\">str s</td><td align=\"left\">expect string</td></tr><tr><td align=\"left\">chr c</td><td align=\"left\">expect char</td></tr><tr><td align=\"left\">regex r</td><td align=\"left\">expect regex</td></tr><tr><td align=\"left\">p \n<code>&#x3C;*></code>\n q</td><td align=\"left\">execute q only if p succeeds</td></tr><tr><td align=\"left\">p \n<code>&#x3C;|></code>\n q</td><td align=\"left\">execute q only if p fails</td></tr><tr><td align=\"left\">p \n<code>&#x3C;*</code>\n q</td><td align=\"left\">same with \n<code>&#x3C;*></code>\n but throw the result of q away</td></tr><tr><td align=\"left\">p \n<code>*></code>\n q</td><td align=\"left\">same with \n<code>&#x3C;*></code>\n but throw the result of p away</td></tr><tr><td align=\"left\">p \n<code>>></code>\n fnq</td><td align=\"left\">apply the result of p to fnq then execute the return parser</td></tr><tr><td align=\"left\">p \n<code>^^</code>\n fn</td><td align=\"left\">apply the result of p to fn</td></tr><tr><td align=\"left\">rep p</td><td align=\"left\">repeat p</td></tr><tr><td align=\"left\">rep1 p</td><td align=\"left\">repeat p at least once</td></tr><tr><td align=\"left\">opt p</td><td align=\"left\">execute p zero or once</td></tr><tr><td align=\"left\">andPred p</td><td align=\"left\">execute p without consuming the input</td></tr><tr><td align=\"left\">notPred p</td><td align=\"left\">succeeds only if p fails without consuming the input</td></tr></tbody></table>\n<h2 id=\"license\"><a aria-hidden=\"true\" href=\"#license\"><span class=\"icon icon-link\"></span></a>License</h2>\n<p>MIT</p>"}