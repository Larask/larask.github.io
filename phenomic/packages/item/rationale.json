{"filename":"rationale.json","type":"published","id":"rationale","name":"rationale","version":"0.1.3","description":"Rationale is a collection of helper utility functions that are absent in the OCaml/ReasonML standard library.","license":"MIT","keywords":["lodash","ramda","bucklescript","monad","reason"],"analyzed":"2017-12-22T17:38:28.649Z","updated":"2017-12-22T17:38:28.649Z","stars":32,"score":0.5785005873372709,"quality":0.7011076458988124,"popularity":0.05557291415779631,"maintenance":0.9963364960354244,"homepageUrl":"https://github.com/jonlaing/rationale#readme","repositoryUrl":"https://github.com/jonlaing/rationale","npmUrl":"https://www.npmjs.com/package/rationale","issuesUrl":"https://github.com/jonlaing/rationale/issues","docsUrl":null,"path":"packages/rationale","body":"<h1 id=\"rationale\"><a aria-hidden=\"true\" href=\"#rationale\"><span class=\"icon icon-link\"></span></a>Rationale</h1>\n<p>Rationale is inspired by <a href=\"http://ramdajs.com/\">RamdaJS</a>. It is a collection of helper utility functions that are absent in the OCaml/ReasonML standard library.</p>\n<p>Note that not all of Ramda was ported over, as many of Ramda's utilities are making up for deficits in Javascript, which Reason doesn't have. Furthermore, many of the functions that operate on objects, simply don't make sense in Reason.</p>\n<h2 id=\"features\"><a aria-hidden=\"true\" href=\"#features\"><span class=\"icon icon-link\"></span></a>Features</h2>\n<h3 id=\"exception-free-list-operations\"><a aria-hidden=\"true\" href=\"#exception-free-list-operations\"><span class=\"icon icon-link\"></span></a>Exception-free List operations</h3>\n<p>In the OCaml/ReasonML standard library, many of the common List operations throw exceptions if there's a problem. Rationale's utilities do not throw exceptions, and instead return <code>options</code>.</p>\n<ul>\n<li>head</li>\n<li>tail</li>\n<li>init</li>\n<li>last</li>\n<li>nth</li>\n<li>etc</li>\n</ul>\n<h3 id=\"monadic-options-and-jsresults\"><a aria-hidden=\"true\" href=\"#monadic-options-and-jsresults\"><span class=\"icon icon-link\"></span></a>Monadic Options and Js.Results</h3>\n<p>Rationale includes monadic and functor operations ala Haskell for the <code>option</code> and <code>Js.Result</code> types.</p>\n<pre><code class=\"hljs language-Reason\">open Rationale.Option.Infix;\nopen Rationale.Function;\n\nRList.init(a)\n  >>= <span class=\"hljs-function\">(<span class=\"hljs-params\">(<span class=\"hljs-params\">x</span>) => RList.last(<span class=\"hljs-params\">a</span>) &#x3C;$> f &#x3C;$> flip(<span class=\"hljs-params\">RList.append, x</span>)</span>)\n  &#x3C;$> <span class=\"hljs-params\">RList</span>.<span class=\"hljs-params\">concat</span>(<span class=\"hljs-params\">b</span>)\n  |> <span class=\"hljs-params\">Option</span>.<span class=\"hljs-params\">default</span>(<span class=\"hljs-params\">xs</span>);</span></code></pre>\n<h3 id=\"support-for-point-free-style\"><a aria-hidden=\"true\" href=\"#support-for-point-free-style\"><span class=\"icon icon-link\"></span></a>Support for Point-free style</h3>\n<p>Rationale has <code>compose</code> and <code>pipe</code> functions, as well as supporting infix operators: <code>&#x3C;||</code> and <code>||></code> respectively.</p>\n<h3 id=\"infix-lens-composition\"><a aria-hidden=\"true\" href=\"#infix-lens-composition\"><span class=\"icon icon-link\"></span></a>Infix Lens composition</h3>\n<p>Rationale also allows for fluid lens composition via infix operators: <code>-&#x3C;&#x3C;</code> and <code>>>-</code>.</p>\n<pre><code class=\"hljs language-Reason\"><span class=\"hljs-selector-tag\">Lens</span><span class=\"hljs-selector-class\">.view</span>(<span class=\"hljs-selector-tag\">aLens</span> >><span class=\"hljs-selector-tag\">-</span> <span class=\"hljs-selector-tag\">bLens</span> >><span class=\"hljs-selector-tag\">-</span> <span class=\"hljs-selector-tag\">optional</span>(0), { <span class=\"hljs-attribute\">a</span>: { b: <span class=\"hljs-built_in\">Some</span>(3) } });</code></pre>\n<h3 id=\"function-signatures-for-composition\"><a aria-hidden=\"true\" href=\"#function-signatures-for-composition\"><span class=\"icon icon-link\"></span></a>Function signatures for composition</h3>\n<p>Like in Ramda, functions always keep their data at the end making piping and composing a breeze:</p>\n<pre><code class=\"hljs language-Reason\"><span class=\"hljs-type\">list</span>\n  |> take(<span class=\"hljs-number\">9</span>)\n  |> drop(<span class=\"hljs-number\">3</span>)\n  |> splitAt(<span class=\"hljs-number\">4</span>);</code></pre>\n<h2 id=\"usage\"><a aria-hidden=\"true\" href=\"#usage\"><span class=\"icon icon-link\"></span></a>Usage</h2>\n<h3 id=\"using-optional-returns-in-rlist-and-dict\"><a aria-hidden=\"true\" href=\"#using-optional-returns-in-rlist-and-dict\"><span class=\"icon icon-link\"></span></a>Using Optional Returns in RList and Dict</h3>\n<p>Returning <code>option('a)</code> from functions is generally preferred to throwing an exception.\nIt protects you from runtime errors, and forces you to deal with potential errors at\ncompile time. However, if you're not used to doing it, things can get a little\nconfusing.</p>\n<p>Pattern matching for errors all the time would be extremely cumbersome. Fortunately,\nwe provide a host of useful methods to working with optional returns. Hopefully,\nthis doc will show you that you don't need to use excessive pattern matching to\nwork with optional returns.</p>\n<h4 id=\"default\"><a aria-hidden=\"true\" href=\"#default\"><span class=\"icon icon-link\"></span></a>Default</h4>\n<p>The most straight forward way to get out of an <code>option</code> is by calling <code>default</code>.</p>\n<pre><code class=\"hljs language-Reason\"><span class=\"hljs-built_in\">Option</span>.<span class=\"hljs-keyword\">default</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">/* 1 */</span>\n\n<span class=\"hljs-built_in\">Option</span>.<span class=\"hljs-keyword\">default</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>); <span class=\"hljs-comment\">/* 0 */</span></code></pre>\n<h4 id=\"monads\"><a aria-hidden=\"true\" href=\"#monads\"><span class=\"icon icon-link\"></span></a>Monads</h4>\n<p>Calling <code>default</code> will definitely get you out of the <code>option</code>, but what if you want\nto do some things to it first? What if you need other funtions that also return <code>option</code>?</p>\n<p>the Option module includes monadic operations for <code>option</code>, so you can take a <em>railway oriented</em>\napproach to working with them.</p>\n<p>First, let's check if the last item of a list is equal to a certain value:</p>\n<pre><code class=\"hljs language-Reason\">let lastEquals = (a, xs) => Option.fmap(Util.eq(a), RList.last(xs)) |> Option.<span class=\"hljs-section\">default</span>(false);\n\nlastEquals(<span class=\"hljs-number\">3</span>, [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">/* true */</span>\nlastEquals(<span class=\"hljs-number\">3</span>, [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>]); <span class=\"hljs-comment\">/* false */</span>\nlastEquals(<span class=\"hljs-number\">3</span>, []); <span class=\"hljs-comment\">/* false */</span>\n\n<span class=\"hljs-comment\">/* Or, with infix operators */</span>\nopen Option.Infix;\n\nlet lastEquals = (a, xs) => RList.last(xs) &#x3C;$> Util.eq(a) |> Option.<span class=\"hljs-section\">default</span>(false);</code></pre>\n<p>Here we used <code>fmap</code> and its infix variation <code>&#x3C;$></code> to apply a function to the value <em>inside</em> the option.\nNote that, <code>Util.eq</code> returns a <code>bool</code> not an <code>option</code>. So what if the next function also returns an\n<code>option</code>? Well you'd get nested options, which doesn't really help anyone. So, instead, we would\nuse <code>bind</code>.</p>\n<p>Now let's replace the last item of one list with the last item of another. Note that both <code>last</code> and\n<code>init</code> return <code>option</code>:</p>\n<pre><code class=\"hljs language-Reason\"><span class=\"hljs-keyword\">let</span> swapLast = <span class=\"hljs-function\">(<span class=\"hljs-params\">xs, ys</span>) =></span>\n  Option.(bind(RList.last(xs), <span class=\"hljs-function\">(<span class=\"hljs-params\">(<span class=\"hljs-params\">x</span>) => fmap(<span class=\"hljs-params\">RList.append(<span class=\"hljs-params\">x</span>), RList.init(<span class=\"hljs-params\">ys</span>)</span>)</span>)) |> <span class=\"hljs-params\">default</span>(<span class=\"hljs-params\">ys</span>));\n\n<span class=\"hljs-params\">swapLast</span>(<span class=\"hljs-params\">[1,2,3], [4,5,6]</span>); /* [4,5,3] */\n<span class=\"hljs-params\">swapLast</span>(<span class=\"hljs-params\">[], [4,5,6]</span>); /* [4,5,6] */\n\n/* <span class=\"hljs-params\">Or</span>, <span class=\"hljs-params\">with</span> <span class=\"hljs-params\">infix</span> <span class=\"hljs-params\">operators</span> */\n<span class=\"hljs-params\">open</span> <span class=\"hljs-params\">Option</span>.<span class=\"hljs-params\">Infix</span>;\n\n<span class=\"hljs-params\">let</span> <span class=\"hljs-params\">swapLast</span> = (<span class=\"hljs-params\">xs, ys</span>) =></span>\n  RList.last(xs) >>= <span class=\"hljs-function\">(<span class=\"hljs-params\">(<span class=\"hljs-params\">x</span>) => RList.init(<span class=\"hljs-params\">ys</span>) &#x3C;$> RList.append(<span class=\"hljs-params\">x</span>)</span>) |> <span class=\"hljs-params\">Option</span>.<span class=\"hljs-params\">default</span>(<span class=\"hljs-params\">ys</span>);</span></code></pre>\n<p>Here we used <code>bind</code> and its infix variation <code>>>=</code> to apply a function that also returned an <code>option</code>.</p>\n<h4 id=\"applicatives\"><a aria-hidden=\"true\" href=\"#applicatives\"><span class=\"icon icon-link\"></span></a>Applicatives</h4>\n<p>Let's try checking if the last elements of two lists are equal. We could accomplish this using <code>bind</code>,\nbut that can be a little awkward.</p>\n<pre><code class=\"hljs language-Reason\">let lastEqual = (xs, ys) =>\n  Option.(apply(apply(Some(Util.eq), RList.last(xs), RList.last(ys))) |> <span class=\"hljs-section\">default</span>(false));\n\nlastEqual([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>], [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">/* true */</span>\nlastEqual([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>], [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>]); <span class=\"hljs-comment\">/* false */</span>\nlastEqual([], [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>]); <span class=\"hljs-comment\">/* false */</span>\nlastEqual([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>], []); <span class=\"hljs-comment\">/* false */</span>\n\n<span class=\"hljs-comment\">/* Or, with infix operators */</span>\nopen Option.Infix;\n\nlet lastEqual = (xs, ys) =>\n  Some(Util.eq) &#x3C;*> RList.last(xs) &#x3C;*> RList.last(ys) |> Option.<span class=\"hljs-section\">default</span>(false);</code></pre>\n<h3 id=\"translating-js-idioms\"><a aria-hidden=\"true\" href=\"#translating-js-idioms\"><span class=\"icon icon-link\"></span></a>Translating JS Idioms</h3>\n<h4 id=\"or-chains\"><a aria-hidden=\"true\" href=\"#or-chains\"><span class=\"icon icon-link\"></span></a>Or chains</h4>\n<p>Take the following example in Javascript:</p>\n<pre><code class=\"hljs language-Javascript\"><span class=\"hljs-keyword\">let</span> x = a || b || c || d;</code></pre>\n<p>We can't translate that directly to Reason, because there is no <code>null</code> or <code>undefined</code> in Reason.\nThe closest approximation would be <code>option</code>, in which we can string together <code>Some</code> and <code>None</code>\nto get the first one that is <code>Some</code>.</p>\n<p>There is a helper function called <code>firstSome</code> and its infix variation <code>|?</code> that do exactly this.</p>\n<pre><code class=\"hljs language-Reason\"><span class=\"hljs-comment\">/* a, b, and c are all options, but d is not */</span>\n<span class=\"hljs-keyword\">let</span> x = a |? b |? <span class=\"hljs-built_in\">c</span> |> <span class=\"hljs-keyword\">default</span>(d);</code></pre>\n<h2 id=\"reference\"><a aria-hidden=\"true\" href=\"#reference\"><span class=\"icon icon-link\"></span></a>Reference</h2>\n<h3 id=\"infix-operators\"><a aria-hidden=\"true\" href=\"#infix-operators\"><span class=\"icon icon-link\"></span></a>Infix Operators</h3>\n<ul>\n<li><code>>>=</code>: Monadic Bind</li>\n<li><code>&#x3C;$></code>: Functor Fmap</li>\n<li><code>&#x3C;*></code>: Applicative Apply</li>\n<li><code>&#x3C;||</code>: Point-free Function Compose</li>\n<li><code>||></code>: Point-free Function Pipe</li>\n<li><code>-&#x3C;&#x3C;</code>: Lens Compose</li>\n<li><code>>>-</code>: Lens Pipe</li>\n<li><code>|?</code>: Optional Or</li>\n</ul>"}